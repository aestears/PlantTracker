---
title: "Suggested PlantTracker Workflow"
author: Alice Stears
date: 9 July 2021
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Suggested_PlantTracker_Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  rmarkdown.html_vignette.check_title = FALSE
)
```

```{r setup, include = FALSE}
library(PlantTracker)
library(ggplot2)
```


## Introduction
Welcome to PlantTracker! This package was designed to transform long-term 
quadrat maps that show plant occurrence and size into demographic data that can 
be used to answer questions about population and community ecology. 
This vignette is designed to help you use PlantTracker functions to move from a 
spatially referenced dataset containing plant cover data, to an output dataset 
that contains growth and survival data for each observed individual. 

This vignette will walk you through the steps to get from maps of plant cover 
to a demographic dataset that you can use for analysis!

## *1.* Prepare data
The functions in PlantTracker require data in a specific format. PlantTracker
includes an example dataset that consists of two pieces: 'grasslandData' and 
'grasslandInventory'. You can load these example datasets into your global 
environment by calling `data(grasslandData)` and `data(grasslandInventory)`. You 
can view the documentation for these datasets by calling 
`?grasslandData` and `?grasslandInventory`. 

Most PlantTracker functions require two data objects. The first is a data.frame 
that contains the location and metadata for each mapped individual, which we 
from now on will call 'dat'. The second is a list that contains a vector of 
years in which each quadrat was sampled, which we from now on will cal 'inv'. 
Below are the basic requirements for these data objects.

#### *1.1* The 'dat' data.frame must . . .

*  ... be an sf data.frame. More on this below...

*  ... contain a row for each individual observation in each year. 

*  ... have a column that contains character strings indicating the specific
epithet for each observation. This column must be a character data type. The 
function expects this column to be called 'Species', but a different name can be 
specified in function calls. 

*  ... have a column that contains character strings indicating the site at which 
each observation was collected. This is a level of classification 'above' the 
quadrat (i.e. all quadrats measured at the Central Plains Experimental Range in 
Nunn, CO might have the value "CO" in this column). This column must be a 
character data type. The function expects this column to be called 'Site', but a 
different name can be specified in function calls. 

*  ... have a column that contains character strings indicating the quadrat at which 
each observation was collected. This column must be a character data type. The 
function expects this column to be called 'Quad', but a different name can be 
specified in function calls. 

*  ... have a column that contains a value indicating the year when this individual 
observation was collected. This must be a numeric data type, and must be either 
a four or two digit year number. The function expects this column to be called 
'Year', but a different name can be specified in function calls. 

*  ... have a column (almost always called 'geometry' in the `sf` package data 
format) that contains a polygon representing the location of each observation.
Each observation must be a `POLYGON` or `MULTIPOLYGON`. Data cannot be stored as 
`POINTS`.
    +   If the data was collected such that forbs or small grasses were mapped 
as points and digitized as such, then these observations must be converted to 
polygons. We recommend that you convert them to small circular polygons with an 
identical radius. If you do this transformation, we also recommend that you
include a column that indicates whether each row was originally mapped as a 
polygon or a point, since the demographic data that deals with size will be
relatively meaningless for observations originally mapped as points. 
    +   'dat' does not need to have a coordinate reference system (i.e. CRS can be 
'NA'), but it can have one if you'd like. 

*  ... *not* have columns called 'neighbors', 'nearEdge',  'trackID', 'age', 
'size_tplus1', 'recruit', 'survives_tplus1', 'basalArea_ramet', or 
'basalArea_genet', since these columns are added by PlantTracker functions. 

*  Note: Additional columns can be included in the input data.frame, although 
they might not be included in the output of PlantTracker functions. 

Here are the first few rows of a possible 'dat' input data.frame: 
```{r  echo = FALSE}
dataShow <- head(grasslandData[, !names(grasslandData) %in%
                                  c("Clone", "Seedling", "Stems", "Basal",
                                    "sp_code_4", "Area")])
rownames(dataShow) <- NULL
knitr::kable(dataShow, caption = "**Table 1.1**: Example 'dat' data.frame" )
```

Note that the required columns are 'Species', 'Site', 'Quad', 'Year', and
'geometry'. The additional columns 'Type' and 'sp_code_6' are just "along for 
the ride" in any analysis using PlantTracker functions. 


Here's what some of the example 'dat' data (from the 'SG2' quadrat at the 
'AZ' site in 1922) look like when plotted spatially:    
```{r echo = FALSE,  fig.width=6, fig.align = 'center', fig.cap = "**Figure 1.1**: Spatial map of a subset of example 'dat' dataset"}
exampleDat <- grasslandData[grasslandData$Site == "AZ" & 
                              grasslandData$Quad == "SG2" & 
                              grasslandData$Year == 1922, ]

ggplot(data = exampleDat) +
  geom_sf(aes(color = Species, fill = Species)) +
  geom_segment(aes(x = 0, xend = 1, y = 0, yend = 0), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 1, y = 1, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 0, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 1, xend = 1, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  xlab("quadrat horizontal edge (m)") +
  ylab("quadrat vertical edge (m)") +
  theme_classic() +
  theme(axis.line = element_blank(), 
        legend.text = element_text(face = "italic"),
        plot.margin = margin(1,0,1,0)) 
```

#### *1.2* The 'inv' list must . . .

* ... be a named list

* ... have element names that are each a character string identical to the name 
of a quadrat in 'dat'. There cannot be two elements with the same name, and 
there cannot be an element with more than one quadrat in its name. There must be 
an element for each quadrat with data in 'dat'. 

* ... have list elements that are each a numeric vector of years in which 
each quadrat was sampled. If a quadrat was 'skipped' in a year, then that year 
must be excluded from this vector. The format of the years must be the same as 
the format of years in 'dat' (i.e. if year is a four-digit number in 'dat', then 
it must be a four-digit number in 'inv'). 

Here is an example of an 'inv' argument that corresponds to the example 'dat' 
argument above. The quadrats that have data in 'dat' are "ungz_5a", "unun_11", 
"SG2", and "SG4",  so there are elements in 'inv' that 
correspond to each of these quadrats. 
```{r echo=FALSE, fig.align='center'}
grasslandInventory[c("ungz_5a", "unun_11", "SG2", "SG4")]
```
**Figure 1.2**: An example of the 'inv' argument


#### *1.3* Checking the 'inv' and 'dat' arguments  
This step is optional, but can be useful if you're unsure whether your 'dat' and 
'inv' arguments are in the correct format. The PlantTracker function 
`checkDat()` takes 'dat' and 'inv' as arguments for the arguments `dat` and `inv`, 
and will return informative error messages if either argument is not in the 
correct format. 

Additional optional arguments to `checkDat()` are 'species', 'site', 'quad', 
'year', 'geometry', and 'reformatDat'. 

* `species/site/quad/year/geometry`: These arguments only need to be included if 
the columns in 'dat' that contain the data that indicates the species, site, 
quadrat, year and geometry of each observation are *different* from the names 
"Species", "Site", "Quad", "Year, and "geometry".  For example, if the column in 
your version of 'dat' that contains the character strings that identify the 
species identity of each observation is called 'species_names', then the 
argument `species = "species_names"` must be included in your call 
to `checkDat()`. 

* `reformatDat` is a TRUE/FALSE argument that determines whether you want the 
`checkDat()` function to return a version of 'dat' that is ready to go into the 
steps of this workflow. If `reformatDat` = TRUE then `checkDat()` will return a 
list that contains the reformatted version of 'dat', the reformatted version of 
'inv' and an additional element called 'userColNames', which contains the column 
names in the input version of 'dat' that are different from the expected column 
names of "Species", "Site", "Quad", "Year, and "geometry" (if there are any). If 
`reformatDat` = TRUE, then `checkDat()` will return a message indicating that 
your data is ready for the next step. The default value is FALSE.

### *2.* Track Individuals Through Time
Now it's time to transform your raw dataset into deomgraphic data! This is 
accomplished using the `trackSpp()` function. This function follows individual 
plants from year to year in the same quadrat to determine survival, size in the 
next year, age, and some additional potentially-useful demographic data. It does 
this by comparing quadrat maps from sequential years. If there is overlap of 
individuals of the same species in consecutive years, then the rows in 'dat' 
that contain data for those overlapping individuals are given the same 
'trackID', or unique identifier. `checkDat()` takes the following arguments:  

* `dat` This is the sf data.frame that we've been calling 'dat' so far. This 
must be in the correct format (which you can check before-hand using 
`checkDat()`), but informative error messages will be returned if it is 
incorrect. It *must* have the columns outlined in Section 1.1, but they can have 
different names as long as those names are included in this function call 
(more on that later...).

* `inv` This is the list of quadrat sampling years we've been calling 'inv'. If 
it is not in the correct format or does not contain data for the correct 
quadrats, then an informative error message will be returned. 

* `dorm` This is a positive integer value that indicates how long you want the 
function to allow an individual to be "dormant". In this case, dormancy can be 
interpreted as the biological phenomenon where a plant has above-ground tissue 
present in year 1, is alive underground but with no above-ground tissue in year 
2, and then has above-ground tissue in a subsequent year. Dormancy can also be 
interpreted here as data-collection error, whereby an individual is accidentally 
not mapped inbetween years where it was recorded. 

  *Consider the following example*: There is a polygon of species 'A' in year 1, 
which is our "focal indivdiual". In year 2, there is not a polygon of species 
'A' that overlaps with our focal individual. In year 3, there is a polygon of 
species 'A' that is in the same location as our focal individual. If `dorm` = 0, 
then our focal individual would get a 0 in the survival column, and the polygon 
of species 'A' in year 3 would be considered a new recruit and get a new 
trackID. If `dorm= 1`, because there is overlap between two polygons of the same 
species with only a 1-year gap between when they occur, these two polygons will 
be considered the same genetic individual, will have the same trackID, and our 
focal individual will have a '1' in the survival column. In an alternative 
scenario, in years 3 and 4 there are not polygons of species 'A' that are in the 
same location as our focal individual, but there is a polygon in year 4 that 
overlaps our focal individual. If `dorm = 1`, then our focal individual would 
get a 0 for survival, but if `dorm = 2`, then it would get a 1 for survival. 
```{r echo = FALSE, fig.width=6, fig.align = 'center', fig.cap = "**Figure 2.1**: A visualization of the 'dormancy' scenario described above."}
exampleSmall <- exampleDat[unique(c(30, 42, 44, 25,  2, 61, 59, 52, 45,  8, 42, 37, 60, 34, 45, 38, 26, 49, 52, 46)),]

exampleSmall$FocalInd <- 'other individual'
exampleSmall[10,'FocalInd'] <- 'focal individual'
exampleSmall$Year <- "Year 1"
exampleSmall_2 <- exampleSmall[c(1:9,11:nrow(exampleSmall)),]
exampleSmall_2$Year <- "Year 2"
exampleSmall_3 <- exampleSmall
exampleSmall_3$Year <- "Year 3"

exampleSmall <- rbind(exampleSmall, exampleSmall_2, exampleSmall_3)

ggplot(data = exampleSmall) +
  geom_sf(aes(color = FocalInd, fill = FocalInd)) +
  geom_segment(aes(x = 0, xend = 1, y = 0, yend = 0), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 1, y = 1, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 0, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 1, xend = 1, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  xlab("quadrat horizontal edge (m)") +
  ylab("quadrat vertical edge (m)") +
  #labs(title = Year) +
  facet_wrap( ~ Year) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        legend.text = element_text(face = "italic"),
        plot.margin = margin(1,0,1,0),
        legend.title = element_blank()) +
  scale_fill_discrete(type = c("#E69F00", "#A6A6A6", "#009E73"))  +
  scale_colour_discrete(type = c("#E69F00", "#A6A6A6", "#009E73"))
```
  
  If you'd like to be more specific and perhaps biologically accurate, you can also specify the `dorm` argument uniquely for each species. For example, it might be that you are confident that your data collectors did not accidentally 'miss' any individuals, and your 'dat' data.frame contains observations for shrubs or trees, which are very unlikely to go dormant, and small forbs, which are much more likely to go dormant for one or two years. In order to disallow dormancy for trees and shrubs, but to allow dormancy for forbs, you will provide a data.frame to the `dorm` argument instead of a single positive integer value. There will be two columns: 1) a "Species" column that has the species name for each species present in 'dat', and 2) a column called "dorm" that has positive integer values indicating the dormancy you'd like to allow for each species. Make sure that if you are following the data.frame approach, you must provide a dormancy argument for *every* species that has data in 'dat'. Make sure that the species names in the `dorm` data.frame are spelled exactly the same as they are in 'dat'. The data.frame should look something like this:
```{r echo = FALSE}
dormDF <- data.frame("Species" = c("tree A", "shrub B", "tree C", "forb D", "forb E", "forb F"),
           "dorm" = c(0,0,0,1,2,1))
knitr::kable(dormDF, caption = "**Table 2.1**: Example 'dorm' data.frame", )
```
  
* `buff` This is a positive numeric value that indicates how much an invidual can move from year 1 to year 2 and still be considered the same individual (receive the same trackID). In addition to accounting for true variation in location of a plant's stem from year to year, this argument also accounts for small inconsistencies in mapping from year to year. The `buff` argument must be in the same units as the spatial values in 'dat'. For example, if the spatial data in 'dat' is measured in meters, and you want to allow a plant to 'move' 15 cm between year 1 and year 2, then you would include the argument `buff = .15` in your call to `trackSpp()`. If you want to allow no movement, use `buff = 0`. Below is a visualization of what this `buff` argument does:

```{r echo = FALSE, warning= FALSE, fig.width=7.5, fig.align = 'center', fig.cap = "**Figure 2.2**: With a 10 cm buffer, these polygons in 1922 and 1923 will be identified by trackSpp() as the same individual and receive the same trackID."}

exampleDat <- grasslandData[grasslandData$Site == "AZ" & 
                              grasslandData$Quad == "SG2" & 
                              grasslandData$Year %in% c(1922,1923), ]
exampleDatIDsTemp <- suppressMessages(trackSpp(exampleDat, grasslandInventory, buff = .05, buffGenet = .005, clonal = 1, dorm = 1)) 
exampleDatIDsTemp <- exampleDatIDsTemp[exampleDatIDsTemp$Species == "Bouteloua rothrockii",]

exampleDatIDsTemp <- exampleDatIDsTemp[exampleDatIDsTemp$trackID %in% c("BOUROT_1922_9", "BOUROT_1923_2"),] 
exampleDatIDsTemp$ghost <- "observation from current year"
exampleBuffed <- st_buffer(exampleDatIDsTemp[exampleDatIDsTemp$trackID == "BOUROT_1922_9",], dist = .10)
exampleBuffed$Year <- 1922
exampleBuffed$ghost <- "10 cm buffer"
exampleBuffedNext <- exampleBuffed
exampleBuffedNext$Year <- 1923
ghost <- exampleDatIDsTemp[exampleDatIDsTemp$trackID == "BOUROT_1922_9",]
ghost$Year <- 1923
ghost$ghost <- "polygon location in previous year"
exampleDatIDs <- rbind(exampleDatIDsTemp, ghost, exampleBuffed, exampleBuffedNext )


ggplot(data = exampleDatIDs
       ) +
  geom_sf(aes(fill = ghost, alpha = ghost, color = ghost, lty = ghost)) +
  geom_segment(aes(x = .6, xend = 1, y = .4, yend = .4), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = .6, xend = 1, y = .8, yend = .8), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = .6, xend = .6, y = .4, yend = .8), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 1, xend = 1, y = .4, yend = .8), size = .5, 
               lineend = "round", color = "grey30")+ 
  xlab("quadrat horizontal edge (m)") +
  ylab("quadrat vertical edge (m)") +
  #labs(title = Year) +
  facet_wrap( ~ Year) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        legend.text = element_text(face = "italic"),
        #plot.margin = margin(1,0,1,0),
        legend.title = element_blank()) +
  scale_fill_discrete(type = c("#E69F00", "#009E73", "#A6A6A6")) +
 scale_colour_discrete(type = c("#E69F00", "#009E73", "#A6A6A6")) +
  scale_alpha_discrete(range = c(0, 1, .5)) +
  scale_linetype_manual(values=c("twodash", "solid", "dotted"))
```  

```{r echo = FALSE, warning= FALSE, fig.width=8, fig.align = 'center', fig.cap = "**Figure 2.3**: With a 3 cm buffer, these polygons in 1922 and 1923 don't quite overlap, so will be identified by trackSpp() as different individuals and receive different trackIDs."}

exampleBuffed <- st_buffer(exampleDatIDsTemp[exampleDatIDsTemp$trackID == "BOUROT_1922_9",], dist = .03)
exampleBuffed$Year <- 1922
exampleBuffed$ghost <- "3 cm buffer"
exampleBuffedNext <- exampleBuffed
exampleBuffedNext$Year <- 1923
ghost <- exampleDatIDsTemp[exampleDatIDsTemp$trackID == "BOUROT_1922_9",]
ghost$Year <- 1923
ghost$ghost <- "polygon location in previous year"
exampleDatIDs <- rbind(exampleDatIDsTemp, ghost, exampleBuffed, exampleBuffedNext )


ggplot(data = exampleDatIDs
       ) +
  geom_sf(aes(fill = ghost, alpha = ghost, color = ghost, lty = ghost)) +
  geom_segment(aes(x = .6, xend = 1, y = .4, yend = .4), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = .6, xend = 1, y = .8, yend = .8), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = .6, xend = .6, y = .4, yend = .8), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 1, xend = 1, y = .4, yend = .8), size = .5, 
               lineend = "round", color = "grey30") + 
  xlab("quadrat horizontal edge (m)") +
  ylab("quadrat vertical edge (m)") +
  #labs(title = Year) +
  facet_wrap( ~ Year) +
  theme_classic() +
  theme(axis.line = element_blank(), 
        legend.text = element_text(face = "italic"),
        #plot.margin = margin(1,0,1,0),
        legend.title = element_blank()) +
  scale_fill_discrete(type = c("#E69F00", "#009E73", "#A6A6A6")) +
 scale_colour_discrete(type = c("#E69F00", "#009E73", "#A6A6A6")) +
  scale_alpha_discrete(range = c(0, 1, .5)) +
  scale_linetype_manual(values=c("twodash", "solid", "dotted"))
```  

