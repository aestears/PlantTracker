---
title: "Suggested PlantTracker Workflow"
author: Alice Stears
date: 9 July 2021
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Suggested_PlantTracker_Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  rmarkdown.html_vignette.check_title = FALSE
)
```

```{r setup, include = FALSE}
library(PlantTracker)
library(ggplot2)
```


## Introduction
Welcome to PlantTracker! This package was designed to transform long-term 
quadrat maps that show plant occurrence and size into demographic data that can 
be used to answer questions about population and community ecology. 
This vignette is designed to help you use PlantTracker functions to move from a 
spatially referenced dataset containing plant cover data, to an output dataset 
that contains growth and survival data for each observed individual. 

This vignette will walk you through the steps to get from maps of plant cover 
to a demographic dataset that you can use for analysis!

## *1* Prepare data
The functions in PlantTracker require data in a specific format. PlantTracker
includes an example dataset that consists of two pieces: 'grasslandData' and 
'grasslandInventory'. You can load these example datasets into your global 
environment by calling `data(grasslandData)` and `data(grasslandInventory)`. You 
can view the documentation for these datasets by calling 
`?grasslandData` and `?grasslandInventory`. 

Most PlantTracker functions require two data objects. The first is a data.frame 
that contains the location and metadata for each mapped individual, which we 
from now on will call 'dat'. The second is a list that contains a vector of 
years in which each quadrat was sampled, which we from now on will cal 'inv'. 
Below are the basic requirements for these data objects.

#### *1.1* The 'dat' data.frame must . . .

*  ... be an sf data.frame. More on this below...

*  ... contain a row for each individual observation in each year. 

*  ... have a column that contains character strings indicating the specific
epithet for each observation. This column must be a character data type. The 
function expects this column to be called 'Species', but a different name can be 
specified in function calls. 

*  ... have a column that contains character strings indicating the site at which 
each observation was collected. This is a level of classification 'above' the 
quadrat (i.e. all quadrats measured at the Central Plains Experimental Range in 
Nunn, CO might have the value "CO" in this column). This column must be a 
character data type. The function expects this column to be called 'Site', but a 
different name can be specified in function calls. 

*  ... have a column that contains character strings indicating the quadrat at which 
each observation was collected. This column must be a character data type. The 
function expects this column to be called 'Quad', but a different name can be 
specified in function calls. 

*  ... have a column that contains a value indicating the year when this individual 
observation was collected. This must be a numeric data type, and must be either 
a four or two digit year number. The function expects this column to be called 
'Year', but a different name can be specified in function calls. 

*  ... have a column (almost always called 'geometry' in the `sf` package data 
format) that contains a polygon representing the location of each observation.
Each observation must be a `POLYGON` or `MULTIPOLYGON`. Data cannot be stored as 
`POINTS`.
    +   If the data was collected such that forbs or small grasses were mapped 
as points and digitized as such, then these observations must be converted to 
polygons. We recommend that you convert them to small circular polygons with an 
identical radius. If you do this transformation, we also recommend that you
include a column that indicates whether each row was originally mapped as a 
polygon or a point, since the demographic data that deals with size will be
relatively meaningless for observations originally mapped as points. 
    +   'dat' does not need to have a coordinate reference system (i.e. CRS can be 
'NA'), but it can have one if you'd like. 

*  ... *not* have columns called 'neighbors', 'nearEdge',  'trackID', 'age', 
'size_tplus1', 'recruit', 'survives_tplus1', 'basalArea_ramet', or 
'basalArea_genet', since these columns are added by PlantTracker functions. 

*  Note: Additional columns can be included in the input data.frame, although it 
might not be included in the output of PlantTracker functions. 

Here are the first few rows of a possible 'dat' input data.frame: 
```{r  echo = FALSE}
dataShow <- head(grasslandData[, !names(grasslandData) %in%
                                  c("Clone", "Seedling", "Stems", "Basal",
                                    "sp_code_4", "Area")])
rownames(dataShow) <- NULL
knitr::kable(dataShow, caption = "**Table 1.1**: Example 'dat' data.frame", )
```

Note that the required columns are 'Species', 'Site', 'Quad', 'Year', and
'geometry'. The additional columns 'Type' and 'sp_code_6' are just "along for 
the ride" in any analysis using PlantTracker functions. 


Here's what some of the example 'dat' data (from the 'SG2' quadrat at the 
'AZ' site in 1922) look like when plotted spatially:    
```{r echo = FALSE,  fig.width=6, fig.align = 'center', fig.cap = "**Figure 1.1**: Spatial map of a subset of example 'dat' dataset"}
exampleDat <- grasslandData[grasslandData$Site == "AZ" & 
                              grasslandData$Quad == "SG2" & 
                              grasslandData$Year == 1922, ]

ggplot(data = exampleDat) +
  geom_sf(aes(color = Species, fill = Species)) +
  geom_segment(aes(x = 0, xend = 1, y = 0, yend = 0), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 1, y = 1, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 0, xend = 0, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  geom_segment(aes(x = 1, xend = 1, y = 0, yend = 1), size = .5, 
               lineend = "round", color = "grey30") + 
  xlab("quadrat horizontal edge (m)") +
  ylab("quadrat vertical edge (m)") +
  theme_classic() +
  theme(axis.line = element_blank(), 
        legend.text = element_text(face = "italic"),
        plot.margin = margin(1,0,1,0)) 
```

#### *1.2* The 'inv' list must . . .

* ... be a named list

* ... have element names that are each a character string identical to the name 
of a quadrat in 'dat'. There cannot be two elements with the same name, and 
there cannot be an element with more than one quadrat in its name. There must be 
an element for each quadrat with data in 'dat'. 

* ... have list elements that are each a numeric vector of years in which 
each quadrat was sampled. If a quadrat was 'skipped' in a year, then that year 
must be excluded from this vector. The format of the years must be the same as 
the format of years in 'dat' (i.e. if year is a four-digit number in 'dat', then 
it must be a four-digit number in 'inv'). 

Here is an example of an 'inv' argument that corresponds to the example 'dat' 
argument above. The quadrats that have data in 'dat' are "ungz_5a", "unun_11", 
"SG2", and "SG4",  so there are elements in 'inv' that 
correspond to each of these quadrats. 
```{r echo=FALSE, fig.align='center'}
grasslandInventory[c("ungz_5a", "unun_11", "SG2", "SG4")]
```
**Figure 1.2**: An example of the 'inv' argument


#### *1.3* Checking the 'inv' and 'dat' arguments  
This step is optional, but can be useful if you're unsure whether your 'dat' and 
'inv' arguments are in the correct format. The PlantTracker function 
`checkDat()` takes 'dat' and 'inv' as arguments, and will return informative 
error messages if either argument is not in the correct format. 

Additional optional arguments to `checkDat()` are 'species', 'site', 'quad', 
'year', 'geometry', and 'reformatDat'. 

